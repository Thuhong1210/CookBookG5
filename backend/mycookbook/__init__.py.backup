import collections
import collections.abc
collections.Mapping = collections.abc.Mapping

from flask import Flask, render_template, redirect, url_for, flash, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from werkzeug.security import generate_password_hash, check_password_hash
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = 'mycookbook_secret_key_2024'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///cookbook.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(120), nullable=False)
    # TẠM THỜI BỎ created_at

class Recipe(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text, nullable=False)
    ingredients = db.Column(db.Text, nullable=False)
    instructions = db.Column(db.Text, nullable=False)
    cooking_time = db.Column(db.Integer, nullable=False)
    difficulty = db.Column(db.String(20), nullable=False)
    category = db.Column(db.String(50), nullable=False, default='Khác')
    image_url = db.Column(db.String(200), default='')
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)

class Favorite(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    recipe_id = db.Column(db.Integer, db.ForeignKey('recipe.id'), nullable=False)

class Rating(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    recipe_id = db.Column(db.Integer, db.ForeignKey('recipe.id'), nullable=False)
    rating = db.Column(db.Integer, nullable=False)  # 1-5 stars
    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())

class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    recipe_id = db.Column(db.Integer, db.ForeignKey('recipe.id'), nullable=False)
    comment = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

with app.app_context():
    db.create_all()

# ROUTES CHO TẤT CẢ TRANG
@app.route("/")
def index():
    # Get 6 random recipes for featured
    featured_recipes = Recipe.query.order_by(db.func.random()).limit(6).all()
    featured_with_ratings = []
    for recipe in featured_recipes:
        ratings = Rating.query.filter_by(recipe_id=recipe.id).all()
        avg_rating = sum(r.rating for r in ratings) / len(ratings) if ratings else 0
        user = User.query.get(recipe.user_id)
        featured_with_ratings.append({
            'recipe': recipe,
            'avg_rating': avg_rating,
            'user': user
        })
    return render_template('home.html', featured_recipes=featured_with_ratings)

@app.route("/home.html")
def home_html():
    return render_template('home.html')

@app.route("/allrecipes.html")
def allrecipes():
    recipes = Recipe.query.all()

    # Calculate average ratings for each recipe
    recipes_with_ratings = []
    for recipe in recipes:
        ratings = Rating.query.filter_by(recipe_id=recipe.id).all()
        if ratings:
            avg_rating = sum(r.rating for r in ratings) / len(ratings)
            rating_count = len(ratings)
        else:
            avg_rating = 0
            rating_count = 0

        # Get user for each recipe
        user = User.query.get(recipe.user_id)

        recipes_with_ratings.append({
            'recipe': recipe,
            'avg_rating': avg_rating,
            'rating_count': rating_count,
            'user': user
        })

    return render_template('allrecipes.html', recipes=recipes_with_ratings)

@app.route("/create-recipe.html")
@login_required
def create_recipe_page():
    return render_template('create-recipe.html')

@app.route("/create-recipe", methods=['POST'])
@login_required
def create_recipe():
    if request.method == 'POST':
        title = request.form['title']
        description = request.form['description']
        ingredients = request.form['ingredients']
        instructions = request.form['instructions']
        cooking_time = request.form['cooking_time']
        difficulty = request.form['difficulty']
        category = request.form['category']
        image_url = request.form.get('image_url', '')
        
        # Tạo recipe mới
        new_recipe = Recipe(
            title=title,
            description=description,
            ingredients=ingredients,
            instructions=instructions,
            cooking_time=cooking_time,
            difficulty=difficulty,
            category=category,
            image_url=image_url,
            user_id=current_user.id  # Gán user đang login
        )
        
        db.session.add(new_recipe)
        db.session.commit()
        flash('Recipe created successfully!')
        return redirect(url_for('allrecipes'))

@app.route("/Details.html")
def details():
    # Redirect to first recipe if available, otherwise show error
    first_recipe = Recipe.query.first()
    if first_recipe:
        return redirect(url_for('recipe_details', recipe_id=first_recipe.id))
    else:
        flash('No recipes available!')
        return redirect(url_for('allrecipes'))

@app.route("/recipe/<int:recipe_id>")
def recipe_details(recipe_id):
    recipe = Recipe.query.get_or_404(recipe_id)
    # Get ratings and comments for this recipe
    ratings = Rating.query.filter_by(recipe_id=recipe_id).all()
    comments = Comment.query.filter_by(recipe_id=recipe_id).order_by(Comment.created_at.desc()).all()

    # Calculate average rating
    if ratings:
        avg_rating = sum(r.rating for r in ratings) / len(ratings)
        rating_count = len(ratings)
    else:
        avg_rating = 0
        rating_count = 0

    # Get user info for comments
    comments_with_users = []
    for comment in comments:
        user = User.query.get(comment.user_id)
        comments_with_users.append({
            'comment': comment,
            'user': user
        })

    return render_template('Details.html', recipe=recipe, avg_rating=avg_rating,
                         rating_count=rating_count, comments=comments_with_users)

@app.route("/recipe/<int:recipe_id>/rate", methods=['POST'])
@login_required
def rate_recipe(recipe_id):
    if request.method == 'POST':
        rating_value = int(request.form['rating'])
        if rating_value < 1 or rating_value > 5:
            flash('Rating must be between 1 and 5 stars!')
            return redirect(url_for('recipe_details', recipe_id=recipe_id))

        # Check if user already rated this recipe
        existing_rating = Rating.query.filter_by(user_id=current_user.id, recipe_id=recipe_id).first()
        if existing_rating:
            existing_rating.rating = rating_value
        else:
            new_rating = Rating(user_id=current_user.id, recipe_id=recipe_id, rating=rating_value)
            db.session.add(new_rating)

        db.session.commit()
        flash('Rating submitted successfully!')
        return redirect(url_for('recipe_details', recipe_id=recipe_id))

@app.route("/recipe/<int:recipe_id>/comment", methods=['POST'])
@login_required
def comment_recipe(recipe_id):
    if request.method == 'POST':
        comment_text = request.form['comment'].strip()
        if not comment_text:
            flash('Comment cannot be empty!')
            return redirect(url_for('recipe_details', recipe_id=recipe_id))

        new_comment = Comment(user_id=current_user.id, recipe_id=recipe_id, comment=comment_text)
        db.session.add(new_comment)
        db.session.commit()
        flash('Comment submitted successfully!')
        return redirect(url_for('recipe_details', recipe_id=recipe_id))

@app.route("/login.html")
def login_html():
    return render_template('login.html')

@app.route("/register.html")
def register_html():
    return render_template('register.html')

@app.route("/mybookmark.html")
@login_required
def mybookmark():
    return render_template('mybookmark.html')

@app.route("/userprofile.html")
@login_required
def userprofile():
    return render_template('userprofile.html')

@app.route("/Admin.html")
def admin():
    return render_template('Admin.html')

@app.route("/edit.html")
def edit():
    return render_template('edit.html')

# Routes xử lý đăng nhập/đăng ký - ĐÃ FIX
@app.route("/login", methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        user = User.query.filter_by(email=email).first()
        if user and check_password_hash(user.password_hash, password):
            login_user(user)
            return redirect(url_for('index'))
        flash('Sai email hoặc mật khẩu!')
    return render_template('login.html')

@app.route("/register", methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        
        # Kiểm tra user đã tồn tại
        existing_user = User.query.filter_by(username=username).first()
        if existing_user:
            flash('Username already exists!')
            return render_template('register.html')
            
        existing_email = User.query.filter_by(email=email).first()
        if existing_email:
            flash('Email already exists!')
            return render_template('register.html')
        
        user = User(username=username, email=email, password_hash=generate_password_hash(password))
        db.session.add(user)
        db.session.commit()
        flash('Registration successful! Please login.')
        return redirect(url_for('login'))
    return render_template('register.html')

@app.route("/logout")
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))

@app.route("/search")
def search():
    query = request.args.get('q', '').strip()
    if query:
        # Search in title, description, ingredients, category
        recipes = Recipe.query.filter(
            (Recipe.title.contains(query)) |
            (Recipe.description.contains(query)) |
            (Recipe.ingredients.contains(query)) |
            (Recipe.category.contains(query))
        ).all()

        # Calculate average ratings for each recipe
        recipes_with_ratings = []
        for recipe in recipes:
            ratings = Rating.query.filter_by(recipe_id=recipe.id).all()
            if ratings:
                avg_rating = sum(r.rating for r in ratings) / len(ratings)
                rating_count = len(ratings)
            else:
                avg_rating = 0
                rating_count = 0

            # Get user for each recipe
            user = User.query.get(recipe.user_id)

            recipes_with_ratings.append({
                'recipe': recipe,
                'avg_rating': avg_rating,
                'rating_count': rating_count,
                'user': user
            })

        return render_template('search.html', recipes=recipes_with_ratings, query=query)
    else:
        return redirect(url_for('allrecipes'))

if __name__ == '__main__':
    app.run(debug=True, port=3000)